require('dotenv').config();

const express = require('express');
const cors = require('cors');
const sanitizeHtml = require('sanitize-html');
const multer = require('multer');
const path = require('path');
const { put, list, del } = require('@vercel/blob');
const { createClient } = require('@supabase/supabase-js');

const app = express();
const PORT = process.env.PORT || 5001;

// Initialize Supabase client
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_ANON_KEY
);

app.use(cors());
app.use(express.json());

// Diagnostic endpoint to inspect what Vercel forwards in production.
// This will echo back the method, path, and selected headers so we can
// confirm whether POST/OPTIONS are reaching the serverless handler.
app.all('/api/_diag', (req, res) => {
  const { method, path, headers, body } = req;
  // Only return a subset of headers to keep output small
  const debugHeaders = {
    host: headers.host,
    origin: headers.origin,
    referer: headers.referer || headers.referrer,
    'x-vercel-id': headers['x-vercel-id'],
    'x-vercel-cache': headers['x-vercel-cache'],
    'content-type': headers['content-type']
  };

  res.json({ ok: true, method, path, headers: debugHeaders, bodyProvided: !!Object.keys(body || {}).length });
});


// --- Multer Configuration for File Uploads ---
const storage = multer.memoryStorage(); // Store files in memory temporarily

const upload = multer({
  storage: storage,
  limits: { fileSize: 10000000 } // 10MB limit
}).single('image');

// Helper function to upload to Vercel Blob
async function uploadToBlob(file) {
  try {
    const filename = `${file.fieldname}-${Date.now()}${path.extname(file.originalname)}`;
    const blob = await put(filename, file.buffer, {
      access: 'public',
      token: process.env.BLOB_READ_WRITE_TOKEN,
    });
    return blob.url;
  } catch (error) {
    console.error('Error uploading to Vercel Blob:', error);
    throw error;
  }
}

// Helper function to delete from Vercel Blob
async function deleteFromBlob(url) {
  try {
    if (!url) return;
    const filename = url.split('/').pop();
    await del(filename, {
      token: process.env.BLOB_READ_WRITE_TOKEN,
    });
  } catch (error) {
    console.error('Error deleting from Vercel Blob:', error);
  }
}

/*
--- Database Schema ---

Table: notes
- id: bigint (primary key, auto-increment)
- title: text (not null)
- date: date (not null)
- content: text (not null)
- image_url: text (nullable)

Table: characters
- id: bigint (primary key, auto-increment)
- name: text (not null)
- race: text (not null)
- class: text (not null)
- status: text (nullable)
- location: text (nullable)
- backstory: text (nullable)
- image_url: text (nullable)
- player_type: text (not null)

Table: session_characters (junction table)
- session_id: bigint (foreign key -> notes.id)
- character_id: bigint (foreign key -> characters.id)
- Primary Key: (session_id, character_id)
*/

// SQL for creating tables in Supabase:
/*
create table notes (
  id bigint generated by default as identity primary key,
  title text not null,
  date date not null,
  content text not null,
  image_url text
);

create table characters (
  id bigint generated by default as identity primary key,
  name text not null,
  race text not null,
  class text not null,
  status text,
  location text,
  backstory text,
  image_url text,
  player_type text not null
);

create table session_characters (
  session_id bigint references notes(id) on delete cascade,
  character_id bigint references characters(id) on delete cascade,
  primary key (session_id, character_id)
);
*/

// GET all notes
app.get('/api/notes', async (req, res) => {
  try {
    // Get all notes with their related characters
    const { data: notes, error } = await supabase
      .from('notes')
      .select(`
        *,
        session_characters(
          character_id,
          characters(*)
        )
      `);

    if (error) throw error;

    // Transform the data to match the expected format
    const notesWithCharacters = notes.map(note => ({
      id: note.id,
      title: note.title,
      date: note.date,
      content: note.content,
      imageUrl: note.image_url,
      characters: note.session_characters.map(sc => ({
        id: sc.characters.id,
        name: sc.characters.name,
        race: sc.characters.race,
        class: sc.characters.class,
        status: sc.characters.status,
        location: sc.characters.location,
        backstory: sc.characters.backstory,
        imageUrl: sc.characters.image_url,
        playerType: sc.characters.player_type
      }))
    }));

    res.json(notesWithCharacters);
  } catch (error) {
    console.error('Error fetching notes:', error);
    res.status(500).json({ message: 'Error fetching notes', error: error.message });
  }
});

// POST a new note
app.post('/api/notes', (req, res) => {
  upload(req, res, async (err) => {
    try {
      if (err) {
        return res.status(500).json({ message: 'Error uploading file.', error: err });
      }
      const { title, content, date, characterIds } = req.body;
      if (!title || !content) return res.status(400).json({ message: 'Title and content required' });

      // Check for existing note with same title
      const { data: existingNote, error: checkError } = await supabase
        .from('notes')
        .select('id')
        .ilike('title', title)
        .single();

      if (checkError && checkError.code !== 'PGRST116') { // PGRST116 means no rows returned
        throw checkError;
      }

      if (existingNote) {
        return res.status(409).json({ message: 'A session with this title already exists.' });
      }

      // Handle image upload to Vercel Blob
      let imageUrl = null;
      if (req.file) {
        imageUrl = await uploadToBlob(req.file);
      }

      const sanitizedTitle = sanitizeHtml(title, { allowedTags: [], allowedAttributes: {} });
      const sanitizedContent = sanitizeHtml(content);

      // Insert into Supabase
      const { data: newNote, error } = await supabase
        .from('notes')
        .insert({
          title: sanitizedTitle,
          date,
          content: sanitizedContent,
          image_url: imageUrl
        })
        .select()
        .single();

      if (error) throw error;

      // If characterIds are provided, create the relationships
      if (characterIds && newNote) {
        const ids = Array.isArray(characterIds) ? characterIds : [characterIds];
        const relationships = ids.map(charId => ({
          session_id: newNote.id,
          character_id: parseInt(charId)
        }));

        if (relationships.length > 0) {
          const { error: relationshipError } = await supabase
            .from('session_characters')
            .insert(relationships);
          if (relationshipError) throw relationshipError;
        }
      }

      res.status(201).json({
        id: newNote.id,
        title: newNote.title,
        date: newNote.date,
        content: newNote.content,
        imageUrl: newNote.image_url,
        characters: []
      });
    } catch (error) {
      console.error('Error creating note:', error);
      res.status(500).json({ message: 'Error creating note', error: error.message });
    }
  });
});

// GET a single note by ID
app.get('/api/notes/:id', async (req, res) => {
  try {
    const noteId = parseInt(req.params.id);
    if (isNaN(noteId)) {
      return res.status(400).json({ message: 'Invalid note ID.' });
    }

    const { data: note, error } = await supabase
      .from('notes')
      .select(`
        *,
        session_characters(
          character_id,
          characters(*)
        )
      `)
      .eq('id', noteId)
      .single();

    if (error || !note) {
      // Supabase returns an error if .single() doesn't find a row
      return res.status(404).json({ message: 'Note not found' });
    }

    // Transform the data to match the expected frontend format
    const noteWithCharacters = {
      ...note,
      imageUrl: note.image_url,
      characters: note.session_characters.map(sc => sc.characters)
    };

    res.json(noteWithCharacters);
  } catch (error) {
    console.error(`Error fetching note with id ${req.params.id}:`, error);
    res.status(500).json({ message: 'Error fetching note', error: error.message });
  }
});

// PUT (update) a note
app.put('/api/notes/:id', (req, res) => {
  upload(req, res, async (err) => {
    try {
      if (err) {
        return res.status(500).json({ message: 'Error uploading file.', error: err });
      }
      const noteId = parseInt(req.params.id);

      // Get existing note
      const { data: existingNote, error: fetchError } = await supabase
        .from('notes')
        .select('*')
        .eq('id', noteId)
        .single();

      if (fetchError || !existingNote) {
        return res.status(404).json({ message: 'Note not found' });
      }

      if (req.body.title) {
        // Check for duplicate title
        const { data: duplicateNote, error: checkError } = await supabase
          .from('notes')
          .select('id')
          .ilike('title', req.body.title)
          .neq('id', noteId)
          .single();

        if (checkError && checkError.code !== 'PGRST116') throw checkError;
        if (duplicateNote) {
          return res.status(409).json({ message: 'Another session with this title already exists.' });
        }
      }

      // Sanitize the body
      const sanitizedBody = {};
      if (req.body.title) sanitizedBody.title = sanitizeHtml(req.body.title, { allowedTags: [], allowedAttributes: {} });
      if (req.body.content) sanitizedBody.content = sanitizeHtml(req.body.content);
      if (req.body.date) sanitizedBody.date = sanitizeHtml(req.body.date, { allowedTags: [], allowedAttributes: {} });

      // Handle image upload to Vercel Blob
      let imageUrl = existingNote.image_url;
      if (req.file) {
        // Delete old image if it exists
        if (existingNote.image_url) {
          await deleteFromBlob(existingNote.image_url);
        }
        imageUrl = await uploadToBlob(req.file);
      }

      // Update in Supabase
      const { data: updatedNote, error: updateError } = await supabase
        .from('notes')
        .update({
          title: sanitizedBody.title || existingNote.title,
          content: sanitizedBody.content || existingNote.content,
          date: sanitizedBody.date || existingNote.date,
          image_url: imageUrl
        })
        .eq('id', noteId)
        .select(`
          *,
          session_characters(
            character_id,
            characters(*)
          )
        `)
        .single();

      if (updateError) throw updateError;

      // Transform the response
      const response = {
        id: updatedNote.id,
        title: updatedNote.title,
        date: updatedNote.date,
        content: updatedNote.content,
        imageUrl: updatedNote.image_url,
        characters: updatedNote.session_characters.map(sc => ({
          id: sc.characters.id,
          name: sc.characters.name,
          race: sc.characters.race,
          class: sc.characters.class,
          status: sc.characters.status,
          location: sc.characters.location,
          backstory: sc.characters.backstory,
          imageUrl: sc.characters.image_url,
          playerType: sc.characters.player_type
        }))
      };

      res.json(response);
    } catch (error) {
      console.error('Error updating note:', error);
      res.status(500).json({ message: 'Error updating note', error: error.message });
    }
  });
});

// DELETE a note
app.delete('/api/notes/:id', async (req, res) => {
  try {
    const noteId = parseInt(req.params.id);

    // Get note for image URL
    const { data: note, error: fetchError } = await supabase
      .from('notes')
      .select('image_url')
      .eq('id', noteId)
      .single();

    if (fetchError || !note) {
      return res.status(404).json({ message: 'Note not found' });
    }

    // Delete image from Vercel Blob if it exists
    if (note.image_url) {
      await deleteFromBlob(note.image_url);
    }

    // Delete from Supabase
    const { error: deleteError } = await supabase
      .from('notes')
      .delete()
      .eq('id', noteId);

    if (deleteError) throw deleteError;

    res.status(204).send();
  } catch (error) {
    console.error('Error deleting note:', error);
    res.status(500).json({ message: 'Error deleting note', error: error.message });
  }
});

// --- CHARACTERS API ---

// GET all characters
app.get('/api/characters', async (req, res) => {
  try {
    // Get all characters
    const { data: characters, error: charError } = await supabase
      .from('characters')
      .select(`
        *,
        session_characters(
          session_id,
          notes(*)
        )
      `);

    if (charError) throw charError;

    // Transform the data to match the expected format
    const charactersWithSessions = characters.map(character => ({
      id: character.id,
      name: character.name,
      race: character.race,
      class: character.class,
      status: character.status,
      location: character.location,
      backstory: character.backstory,
      imageUrl: character.image_url,
      playerType: character.player_type,
      sessions: character.session_characters.map(sc => sc.notes)
    }));

    res.json(charactersWithSessions);
  } catch (error) {
    console.error('Error fetching characters:', error);
    res.status(500).json({ message: 'Error fetching characters', error: error.message });
  }
});

// POST a new character
app.post('/api/characters', (req, res) => {
  upload(req, res, async (err) => {
    try {
      if (err) {
        return res.status(500).json({ message: 'Error uploading file.', error: err });
      }
      // Check for required fields from the original body
      if (!req.body.name || !req.body.race || !req.body.class || !req.body.playerType) {
        return res.status(400).json({ message: 'Name, race, and class are required' });
      }

      const sanitizedBody = {};
      for (const key in req.body) {
        if (key === 'backstory') {
          sanitizedBody[key] = sanitizeHtml(req.body[key]); // Use default safe tags for backstory
        } else {
          sanitizedBody[key] = sanitizeHtml(req.body[key], { allowedTags: [], allowedAttributes: {} });
        }
      }

      // Handle image upload to Vercel Blob
      let imageUrl = null;
      if (req.file) {
        imageUrl = await uploadToBlob(req.file);
      }

      // Insert into Supabase
      const { data: newChar, error } = await supabase
        .from('characters')
        .insert({
          name: sanitizedBody.name,
          race: sanitizedBody.race,
          class: sanitizedBody.class,
          status: sanitizedBody.status,
          location: sanitizedBody.location,
          backstory: sanitizedBody.backstory,
          image_url: imageUrl,
          player_type: sanitizedBody.playerType
        })
        .select()
        .single();

      if (error) throw error;

      res.status(201).json({
        id: newChar.id,
        name: newChar.name,
        race: newChar.race,
        class: newChar.class,
        status: newChar.status,
        location: newChar.location,
        backstory: newChar.backstory,
        imageUrl: newChar.image_url,
        playerType: newChar.player_type
      });
    } catch (error) {
      console.error('Error creating character:', error);
      res.status(500).json({ message: 'Error creating character', error: error.message });
    }
  });
});

// PUT (update) a character
app.put('/api/characters/:id', (req, res) => {
  upload(req, res, async (err) => {
    try {
      if (err) {
        return res.status(500).json({ message: 'Error uploading file.', error: err });
      }

      const charId = parseInt(req.params.id);

      // Get existing character
      const { data: existingChar, error: fetchError } = await supabase
        .from('characters')
        .select('*')
        .eq('id', charId)
        .single();

      if (fetchError || !existingChar) {
        return res.status(404).json({ message: 'Character not found' });
      }

      // Sanitize the incoming data
      const sanitizedBody = {};
      for (const key in req.body) {
        // Skip empty values unless they're intentionally falsy
        if (req.body[key] === null || req.body[key] === undefined) continue;

        if (key === 'backstory') {
          sanitizedBody[key] = sanitizeHtml(req.body[key]); // Use default safe tags for backstory
        } else {
          sanitizedBody[key] = sanitizeHtml(req.body[key], { allowedTags: [], allowedAttributes: {} });
        }
      }

      // Handle the image
      let imageUrl = existingChar.image_url; // Start with existing image
      if (req.file) {
        // Delete old image if it exists
        if (existingChar.image_url) {
          await deleteFromBlob(existingChar.image_url);
        }
        // Upload new image
        imageUrl = await uploadToBlob(req.file);
      } else if (sanitizedBody.imageUrl) {
        imageUrl = sanitizedBody.imageUrl; // Use provided imageUrl
      }

      // Update in Supabase
      const { data: updatedChar, error: updateError } = await supabase
        .from('characters')
        .update({
          name: sanitizedBody.name || existingChar.name,
          race: sanitizedBody.race || existingChar.race,
          class: sanitizedBody.class || existingChar.class,
          status: sanitizedBody.status || existingChar.status,
          location: sanitizedBody.location || existingChar.location,
          backstory: sanitizedBody.backstory || existingChar.backstory,
          image_url: imageUrl,
          player_type: sanitizedBody.playerType || existingChar.player_type
        })
        .eq('id', charId)
        .select()
        .single();

      if (updateError) throw updateError;

      res.json({
        id: updatedChar.id,
        name: updatedChar.name,
        race: updatedChar.race,
        class: updatedChar.class,
        status: updatedChar.status,
        location: updatedChar.location,
        backstory: updatedChar.backstory,
        imageUrl: updatedChar.image_url,
        playerType: updatedChar.player_type
      });
    } catch (error) {
      console.error('Error updating character:', error);
      res.status(500).json({ message: 'Error updating character', error: error.message });
    }
  });
});

// DELETE a character
app.delete('/api/characters/:id', async (req, res) => {
  try {
    const charId = parseInt(req.params.id);

    // Get character for image URL
    const { data: character, error: fetchError } = await supabase
      .from('characters')
      .select('image_url')
      .eq('id', charId)
      .single();

    if (fetchError || !character) {
      return res.status(404).json({ message: 'Character not found' });
    }

    // Delete image from Vercel Blob if it exists
    if (character.image_url) {
      await deleteFromBlob(character.image_url);
    }

    // Delete from Supabase
    const { error: deleteError } = await supabase
      .from('characters')
      .delete()
      .eq('id', charId);

    if (deleteError) throw deleteError;

    res.status(204).send();
  } catch (error) {
    console.error('Error deleting character:', error);
    res.status(500).json({ message: 'Error deleting character', error: error.message });
  }
});

// --- RELATIONSHIP API ---

// Add a character to a session
app.post('/api/notes/:noteId/characters', async (req, res) => {
  try {
    const sessionId = parseInt(req.params.noteId);
    const { characterId } = req.body;

    // Check if relationship already exists
    const { data: existing, error: checkError } = await supabase
      .from('session_characters')
      .select('*')
      .eq('session_id', sessionId)
      .eq('character_id', characterId)
      .single();

    if (checkError && checkError.code !== 'PGRST116') throw checkError;
    if (existing) return res.status(409).json({ message: 'Character already in this session' });

    // Create the relationship
    const { error: insertError } = await supabase
      .from('session_characters')
      .insert({
        session_id: sessionId,
        character_id: characterId
      });

    if (insertError) throw insertError;

    res.status(201).send();
  } catch (error) {
    console.error('Error adding character to session:', error);
    res.status(500).json({ message: 'Error adding character to session', error: error.message });
  }
});

// Remove a character from a session
app.delete('/api/notes/:noteId/characters/:characterId', async (req, res) => {
  try {
    const sessionId = parseInt(req.params.noteId);
    const characterId = parseInt(req.params.characterId);

    const { error } = await supabase
      .from('session_characters')
      .delete()
      .eq('session_id', sessionId)
      .eq('character_id', characterId);

    if (error) throw error;

    res.status(204).send();
  } catch (error) {
    console.error('Error removing character from session:', error);
    res.status(500).json({ message: 'Error removing character from session', error: error.message });
  }
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`âœ… Backend running on port ${PORT}`);
});

module.exports = app;
